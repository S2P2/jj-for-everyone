# Working with remotes

We now have a commit which we don't want to lose.
The way we're using Jujutsu right now, we don't have a backup at all.
If we delete the directory on disk, the `.git` and `.jj` subdirectories will be deleted as well and we won't be able to recover any of our work.

We can fix that by duplicating our commit at another location, a so-called **remote**.
Besides providing a backup, sending commits to a remote also allows you to share your work more easily for collaboration.

The most common form of a remote is to host a repository with an online service like [GitHub](https://github.com/).
For maximum realism, it would be good to that for this tutorial and you certainly can.
However, I will explain a simpler approach, which is to just have a second repository in a different location on you file system.
These two options work pretty much exactly the same way.
When you set up a remote, you just tell Jujutsu where it is.
In the case of an online service, that will be a web URL.
In the case of a local repository, that will be a file system path.
There are no other differences, so we're not missing out on any important lessons by avoiding GitHub.
At the end of this section, there are a few tips about using GitHub itself.

## Initializing the remote

We start by creating a new directory in a different location than our main repository.
Let's go with `~/jj-tutorial-remote`.
Next, we run the command `git init --bare` in it.
Notice that he command **doesn't** start with `jj`, this is a plain Git command.
Jujutsu doesn't have a command to create a bare repository, simply because there's no downside to using Git directly.
Here are the commands:

```sh
mkdir ~/jj-tutorial-remote
cd ~/jj-tutorial-remote
git init --bare
```

````admonish info title="What is a bare repository?" collapsible=true
You don't need to know this, so you can safely skip ahead, but maybe you're curious.
Think of a regular repository as consisting of two parts: (1) Jujutsu's internal database stored in the `.git` and `.jj` directories and (2) all the actual files of your project, which you can modify - your **working copy**.
The term copy is key here, because all the files are also stored in the internal database.
The only reason a copy of the files exist outside the database is so you can interact with them - **work** with them.
So, "working copy" is a fitting name indeed.

A bare repository is basically just a regular repository **without a working copy**.
Since we will only use the remote repository for sending and receiving commits, we don't need a working copy.

If you inspect the content of the new bare repository, it will look very similar in structure to the content of the `.git` directory in our main repository:
```
ls -lah ~/jj-tutorial/.git
ls -lah ~/jj-tutorial-remote
```
````

## Connecting to a remote

Let's go back to our main repository and connect it with the remote we just created.
Here are the commands:

```sh
cd ~/jj-tutorial
jj git remote add origin ~/jj-tutorial-remote
```

The command `jj git remote add` should be self-explanatory, but what about `origin`?
That is the name of the remote.
You can have as many remotes as you like and you can distinguish between them with the name.
In most cases, you will just have one remote and the convention is to use the name `origin`.
The last argument is the location of the remote - the path where we just initialized a second repository.

## Adding a bookmark

There is one last speed bump before we can send our work to the remote.
We can't just send commits willy-nilly, we have to give them a **bookmark** first.
Bookmarks are simple named labels that can be attached to commits.

Let's create a bookmark called **main** and point it to our completed commit.
The name "main" is a convention that represents the primary state of the project.
In legacy projects, the name "master" is also still in widespread use.

```sh
jj bookmark create main --revision rnyzwzlp # <- substitute your change ID here
```

The command `jj bookmark create` expects a name (`main`) and a commit to which the bookmark should point.
We identify the commit by its change ID (`--revision rnyzwzlp`).
The flag `--revision` can also be abbreviated as `-r`.
Let's check the result with `jj log`:

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold purple ">p</span><span class="bold dimgray ">tttyorz</span><span class="bold "> </span><span class="bold yellow ">remo@buenzli.dev</span><span class="bold "> </span><span class="bold cyan ">2025-07-10 14:39:33</span><span class="bold "> </span><span class="bold blue ">7</span><span class="bold dimgray ">553207e</span><span class="bold "></span>
│  <span class="bold "></span><span class="bold green ">(empty)</span><span class="bold "> </span><span class="bold green ">(no description set)</span><span class="bold "></span>
○  <span class="bold "></span><span class="bold purple ">r</span><span class="dimgray ">nyzwzlp</span> <span class="yellow ">remo@buenzli.dev</span> <span class="cyan ">2025-07-10 14:21:14</span> <span class="purple ">main</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">8</span><span class="dimgray ">8938700</span>
│  Add readme with project title
<span class="bold "></span><span class="bold cyan ">◆</span> <span class="bold "></span><span class="bold purple ">z</span><span class="dimgray ">zzzzzzz</span> <span class="green ">root()</span> <span class="bold "></span><span class="bold blue ">0</span><span class="dimgray ">0000000</span>
</pre>

Great!
We can see that the bookmark `main` is correctly pointing to our most recently completed commit.

## Sending commits to a remote

Now that we're connected and have a bookmark, let's finally send our commit to the remote.
The technical term for sending commits is "pushing" them.
You will often hear phrases like "pushing to the remote" or "pushing to GitHub".
The command for pushing a specific bookmark is:

```sh
jj git push --bookmark main
```

That's it!
The expected output is:

```
Changes to push to origin:
  Add bookmark main to ...
```

## Cloning an existing remote

To drive home the point that the remote repository functions as a backup, we're now going to completely delete our main repository and restore it from the remote.
First, the deletion:

```sh
cd ~
rm -rf ~/jj-tutorial
```

The next step is restoring the repo, but you can also think of it in a different way.
Imagine there is an ongoing project and you have just joined the team.
In order to contribute changes to the project, you first need to get a copy of it on your own computer.
The process to do that with Jujutsu is the exact same process as restoring the project from a backup remote.
Here's the command:

```sh
jj git clone --colocate ~/jj-tutorial-remote ~/jj-tutorial
```

The `clone` command takes a flag `--colocate` just like `jj git init` and I recommend you always use it for the same reason.
The last two arguments are (1) the **source** from which to clone and (2) the **destination** - where to store the copied repo. 
Let's run `jj log` in our fresh clone to see if we restored the repo successfully:


```sh
cd ~/jj-tutorial
jj log
```

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">m</span><span class="bold highlighted dimgray ">qksopxt</span><span class="bold "> </span><span class="bold yellow ">remo@buenzli.dev</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-11 16:57:47</span><span class="bold "> </span><span class="bold highlighted blue ">5</span><span class="bold highlighted dimgray ">31e57ca</span><span class="bold "></span>
│  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">r</span><span class="highlighted dimgray ">nyzwzlp</span> <span class="yellow ">remo@buenzli.dev</span> <span class="cyan ">2025-07-11 16:57:47</span> <span class="purple ">main</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">0</span><span class="highlighted dimgray ">112d25d</span>
│  Add readme with project title
~
</pre>

This looks mostly right, but there are little differences.
We can't see the root commit anymore and our commit is marked with a diamond, instead of a circle like before.
As mentioned, the diamond and circle markers are related to a feature we'll learn about later.
For now, we can say that ancestors of diamond commits are hidden by default, because you won't care about them most of the time.
We can tell Jujutsu to show us _all_ commits with `jj log --revisions 'all()'`:

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">m</span><span class="bold highlighted dimgray ">qksopxt</span><span class="bold "> </span><span class="bold yellow ">remo@buenzli.dev</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-11 16:57:47</span><span class="bold "> </span><span class="bold highlighted blue ">5</span><span class="bold highlighted dimgray ">31e57ca</span><span class="bold "></span>
│  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">r</span><span class="highlighted dimgray ">nyzwzlp</span> <span class="yellow ">remo@buenzli.dev</span> <span class="cyan ">2025-07-11 16:57:47</span> <span class="purple ">main</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">0</span><span class="highlighted dimgray ">112d25d</span>
│  Add readme with project title
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">z</span><span class="highlighted dimgray ">zzzzzzz</span> <span class="green ">root()</span> <span class="bold "></span><span class="bold blue ">00</span><span class="highlighted dimgray ">000000</span>
</pre>

Great!
Now we can be sure our repository was fully restored from the remote.

## Using GitHub

As promised, here are a few tips about using [GitHub](https://github.com/).
If you are not interested in this, feel free to skip to the next chapter, it won't become relevant later.

I want to mention that GitHub is not the only provider of Git-hosting services, but certainly the most popular one.
Others include [GitLab](https://about.gitlab.com/) and [Codeberg](https://codeberg.org/).
Codeberg is a free instance of [Forgejo](https://forgejo.org/), which is open-source software you can host yourself.

All of these providers work very similarly to what I'm describing below, so you should have no trouble adapting to other providers.

### Authenticating with an SSH key

Jujutsu needs to authenticate as your GitHub user in order to send and receive commits on your behalf.
It's possible to do that with username and password, but it's very tedious and I don't recommend it at all.
If making backup is tedious, you will do it **less often**.
Fewer backups means more risk of losing your work!
So let's make the authentication as seamless as possible.

The best authentication method is to use an SSH key.
It's more convenient and safer than a password.
GitHub has great documentation about how to set that up, so please follow the instructions here:
- [Generating a new SSH key](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)
- [Adding an SSH key to your account](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account)

You can verify the setup with the following command:

```sh
ssh -T git@github.com
```

The expected output is:

```
Hi user! You've successfully authenticated, but GitHub does not provide shell access.
```

### Creating a new repository on GitHub

Skip ahead if you intend to use an already existing repo.

To create a new repository on GitHub, [click here](https://github.com/new) and fill out the form.
All you need to do is choose an owner (probably your username) and a repo name.
Also check that the visibility matches what you want (can be changed later).

If you already have a local repository with content that you want to push to this new remote, make sure to **not initialize the repo with any content**.
That means, no template, no README, no .gitignore and no license.

Finally, click on "Create repository".

### Cloning an existing repo

Navigate to the page of the existing repo in the browser.
You should see a big green button that says "<> Code".
Click on it and select "SSH" in the drop-down (assuming you have set up an SSH key as explained above).
Copy the URL that's displayed.

Finally, paste the URL into Jujutsu's clone command:

```sh
jj git clone --colocate <COPIED_URL>
```
