# Creating a merge commit

I've strung you along for long enough, let's finally create that version with the combined changes.

There are actually two approaches to achieve this, one of them we'll see later.
This time, we're going to create a **merge commit**.
As the name implies, a merge commit merges changes from two (or more!) commits.

Until now, we've created new commits with the command `jj new` and merge commits are no different.
We just have to explicitly specific which commits we want to merge as additional arguments.
You can check the log and use the change IDs of the commits or simply exploit that (1) `main@origin` is pointing to Bob's commit and (2) Alice's commit is the working copy's parent, i.e. `@-`.
A working command is therefore:

```sh
jj new main@origin @-
```

Let's view the result with `jj log`:

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>    <span class="bold "></span><span class="bold highlighted purple ">v</span><span class="bold highlighted dimgray ">oozptoo</span><span class="bold "> </span><span class="bold yellow ">alice@local</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-13 12:46:20</span><span class="bold "> </span><span class="bold highlighted blue ">0</span><span class="bold highlighted dimgray ">d76b632</span><span class="bold "></span>
├─╮  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
│ ○  <span class="bold "></span><span class="bold purple ">k</span><span class="highlighted dimgray ">rpmvwkz</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-07-13 11:59:11</span> <span class="purple ">main?? main@git</span> <span class="bold "></span><span class="bold blue ">f</span><span class="highlighted dimgray ">13dc4df</span>
│ │  Add Python script for greeting the world
<span class="bold "></span><span class="bold highlighted cyan ">◆</span>│  <span class="bold "></span><span class="bold purple ">t</span><span class="highlighted dimgray ">puxswrq</span> <span class="yellow ">bob@local</span> <span class="cyan ">2025-07-13 12:09:45</span> <span class="purple ">main?? main@origin</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">e</span><span class="highlighted dimgray ">64c9ef0</span>
├─╯  Document hello.py in README.md
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">u</span><span class="highlighted dimgray ">tlxsmss</span> <span class="yellow ">remo@buenzli.dev</span> <span class="cyan ">2025-07-13 11:55:15</span> <span class="bold "></span><span class="bold blue ">9</span><span class="highlighted dimgray ">72b9718</span>
│  Add project description to readme
~
</pre>

Interesting!
The resulting merge commit has **two parents** - precisely the ones we specified.
You can confirm that this new commit contains both changes from Alice and Bob:

```sh
cat README.md
cat hello.py
```

Jujutsu tries to be smart about how to combine changes, but not too smart.
Combinging changes which modify the same part of the project leads to a **conflict**.
Conflicts are not necessarily bad, they are just a signal that you need to combine some changes manually, making sure to preserve the spirit of what each change was trying to achieve individually.
How to resolve conflicts is a topic reserved for the next level.

Let's give this merge commit a description and send it to the remote:

```sh
jj describe -m "Combine code and documentation for hello-world"
jj new
jj bookmark move main --to @-
jj git push
```

Phew!
That was intense.
If you run `jj log` now, the complicated branching and merging will be hidden by default.
Remember that you can reveal it with `jj log --revisions 'all()'`.
