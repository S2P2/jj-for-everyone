# Cloning a remote

````admonish reset title="Reset your progress" collapsible=true
To reset your progress to the start of this chapter, run the following command:

```sh
curl https://jj-for-everyone.github.io/reset.sh | bash -s clone
cd ~/jj-tutorial/repo
```
````

At the beginning of the tutorial, we started our journey by initializing a completely new project using `jj git init`.
We then added a remote later, as a backup solution.
In reality, it's often the other way around:
You need to work on a repository that already exists.

Let's simulate that situation by deleting our main repository:

```sh
cd ~
rm -rf ~/jj-tutorial/repo
```

Now, we only have the remote repository left.
How can we get a "local" copy of it so we can continue working?
The jargon for getting a copy of a repo is to **clone** it.
The relevant Jujutsu command is named accordingly:

```sh
jj git clone ~/jj-tutorial/remote ~/jj-tutorial/repo
```

The last two arguments are (1) the **source** from which to clone and (2) the **destination** - where to store the cloned repo. 
When you clone from a remote, you're automatically connected to it with the default name `origin`.

For the tutorial, we also need to recreate our repo-specific authorship configuration:

```sh
cd ~/jj-tutorial/repo
jj config set --repo user.name "Alice"
jj config set --repo user.email "alice@local"
jj metaedit --update-author
```

Let's run `jj log` in our fresh clone to see if everything was restored successfully:

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">u</span><span class="bold highlighted dimgray ">popmymm</span><span class="bold "> </span><span class="bold yellow ">alice@local</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-09-06 20:42:45</span><span class="bold "> </span><span class="bold highlighted blue ">2</span><span class="bold highlighted dimgray ">5716c6f</span><span class="bold "></span>
â”‚  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
<span class="bold "></span><span class="bold highlighted cyan ">â—†</span>  <span class="bold "></span><span class="bold purple ">y</span><span class="highlighted dimgray ">twonzvp</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-09-06 20:42:20</span> <span class="purple ">main</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">0</span><span class="highlighted dimgray ">a518bdd</span>
â”‚  Add project description to readme
~
</pre>

The most recent commit we made is visible, but its ancestors are hidden.
In their place is a tilde **`~`** symbol.
Jujutsu uses some rule to determine which commits you are probably not interesting to you.
These commits are hidden by default in the output of `jj log`.
We can tell Jujutsu to show us _all_ commits with `jj log --revisions 'all()'`:

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">u</span><span class="bold highlighted dimgray ">popmymm</span><span class="bold "> </span><span class="bold yellow ">alice@local</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-09-06 20:42:45</span><span class="bold "> </span><span class="bold highlighted blue ">2</span><span class="bold highlighted dimgray ">5716c6f</span><span class="bold "></span>
â”‚  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
<span class="bold "></span><span class="bold highlighted cyan ">â—†</span>  <span class="bold "></span><span class="bold purple ">y</span><span class="highlighted dimgray ">twonzvp</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-09-06 20:42:20</span> <span class="purple ">main</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">0</span><span class="highlighted dimgray ">a518bdd</span>
â”‚  Add project description to readme
<span class="bold "></span><span class="bold highlighted cyan ">â—†</span>  <span class="bold "></span><span class="bold purple ">p</span><span class="highlighted dimgray ">snzzpwy</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-09-06 20:41:56</span> <span class="bold "></span><span class="bold blue ">02</span><span class="highlighted dimgray ">181db9</span>
â”‚  Add readme with project title
<span class="bold "></span><span class="bold highlighted cyan ">â—†</span>  <span class="bold "></span><span class="bold purple ">z</span><span class="highlighted dimgray ">zzzzzzz</span> <span class="green ">root()</span> <span class="bold "></span><span class="bold blue ">00</span><span class="highlighted dimgray ">000000</span>
</pre>

Both of our commits are here, so our repository was successfully restored from the remote.

```admonish success title="You've completed Level 1 ! ðŸŽ‰"
You made it!
At this point, you have all the skills needed for simple solo projects with proper backup.
If you're planning to use GitHub, the next chapter is an optional one with tips for that.

Let's summarize the workflow again:
1. make changes
1. create a new commit
1. move the bookmark
1. push to the remote

Ideally, you can take a little break now and practice what you've learned.
Once you feel comfortable with the above, come back quickly for level 2.
We're just scratching the surface.

If you need to collaborate with other people, level 2 is just as essential as this one.
I encourage you keep going right away!
```
