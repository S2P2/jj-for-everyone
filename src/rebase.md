# Rebasing

Now that Bob is happy with his second commit, he tries to push it to the remote:

```sh
jj new
jj bookmark move main --to @-
jj git push
```

As you might've already guessed, Bob gets the same error message as Alice did earlier.
He also decides to follow the hint of fetching from the remote (after watching some cat videos):

```sh
jj git fetch
```

Here's what Bob's log looks like now:

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">u</span><span class="bold highlighted dimgray ">zwrnplo</span><span class="bold "> </span><span class="bold yellow ">remo@buenzli.dev</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-13 00:21:44</span><span class="bold "> </span><span class="bold highlighted blue ">c</span><span class="bold highlighted dimgray ">265616c</span><span class="bold "></span>
│  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
○  <span class="bold "></span><span class="bold purple ">y</span><span class="highlighted dimgray ">wzknnvn</span> <span class="yellow ">bob@local</span> <span class="cyan ">2025-07-13 00:21:32</span> <span class="purple ">main?? main@git</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">5</span><span class="highlighted dimgray ">289c1e9</span>
│  Add submission instructions
│ <span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">x</span><span class="highlighted dimgray ">tmzsumm</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-07-13 00:21:32</span> <span class="purple ">main?? main@origin</span> <span class="bold "></span><span class="bold blue ">a</span><span class="highlighted dimgray ">6a7c4f6</span>
╭─┤  <span class="green ">(empty)</span> Combine code and documentation for hello-world
│ │
│ ~
│
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">r</span><span class="highlighted dimgray ">ussxkvv</span> <span class="yellow ">bob@local</span> <span class="cyan ">2025-07-13 00:21:32</span> <span class="bold "></span><span class="bold blue ">7</span><span class="highlighted dimgray ">c4ff459</span>
│  Document hello.py in README.md
~
</pre>

It's basically the same situation.
Bob's and Alice's changes have branched-off into different directions.
To merge them back together, Bob could do the same thing Alice did and create a merge commit.
However, Bob doesn't like merge commits.
Preferring straight lines in his log, he decides to take a different approach from Alice.

Bob is going to pretend like he made his changes on top of Alice's changes all along.
His most recent commit should have Alice's commit as its parent, because that will result in a **linear history**.

There is a Jujutsu command just for this purpose:
It's called `rebase`.
As the name implies, it takes commits from one "base" (some ancestor) and moves them on top of a different "base".
`jj rebase` on its own doesn't work though, it needs to know the **destination** of the operation.
In this case, Bob wants to move his commit on top of the state of the remote `main` bookmark, i.e. Alice's commit.
Therefore, he runs the command:

```sh
jj rebase --destination main@origin
```

What does the log say?

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">u</span><span class="bold highlighted dimgray ">zwrnplo</span><span class="bold "> </span><span class="bold yellow ">remo@buenzli.dev</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-13 00:39:16</span><span class="bold "> </span><span class="bold highlighted blue ">f</span><span class="bold highlighted dimgray ">10e3ab0</span><span class="bold "></span>
│  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
○  <span class="bold "></span><span class="bold purple ">y</span><span class="highlighted dimgray ">wzknnvn</span> <span class="yellow ">bob@local</span> <span class="cyan ">2025-07-13 00:39:16</span> <span class="purple ">main*</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">2</span><span class="highlighted dimgray ">84bfb17</span>
│  Add submission instructions
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">x</span><span class="highlighted dimgray ">tmzsumm</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-07-13 00:21:32</span> <span class="purple ">main@origin</span> <span class="bold "></span><span class="bold blue ">a</span><span class="highlighted dimgray ">6a7c4f6</span>
│  <span class="green ">(empty)</span> Combine code and documentation for hello-world
~
</pre>

Splendid, that's exactly what Bob wanted.
Jujutsu even figured out that the `main` bookmark should probably point to Bob's new commit.
All that's left to do is to rerun `jj git push`.

What Bob has just done is a paradigm shift:
He has **rewritten history**.
The history _used to_ say that Bob's second commit descended from his first one, but now it says it descended from Alice's commit.
The extent of this revisionism is still benign, but as we progress through the book, we will explore the dark arts of history manipulation ever more deeply.

<div style="display: flex; justify-content: center">
<b style="color: red">
TRUTH ITSELF SHALL BEND TO YOUR WILL
</b>
</div>

...ahem, where were we?

I've glossed over a small detail.
I said the `rebase` command moves commit from a _one base_ to a new one.
What is that _previous_ base?
When using the `--destination` flag (or `-d` for short), Jujutsu will select the first shared ancestor of your working copy and the new base as the _old base to rebase from_.
In simple terms, the `rebase` command moves only those commits that's aren't on the destination branch yet.
Since that was only one commit in our example, only that one was moved.

Creating a merge commit and rebasing are both valid ways of recombining changes that branched-off into different directions.
They both have advantages and disadvantages.
Some people care more about one aspect than another, so they end up having strong opinions about which approach is best.
Here's a hopefully balanced overview of the main trade-off:

| | advantage | disadvantage |
| --- | --- | --- |
| **merge** | preserves the history exactly as it happened | can result in a tangled, hard-to-read history |
| **rebase** | results in an easy-to-read, linear history | lies about the order in which things happened |

Once you have determined the correct opinion, please let everybody on the internet know about your important discovery!
