# Branching

```admonish tip title="Welcome to level 1 !" 
If you took a break after finishing level 0, remember that you can [restore your progress](./introduction.md#restoring-your-progress) in the example repo in case you lost it.
```

The previous level only covered situations where you are working on a project on your own.
What if several people want to collaborate on the project?
Let's simulate such a scenario and see what happens.

Alice and Bob are working on a group project for a computer science class.
Their task is to write the classic "Hello, world!" program in Python.
Alice and Bob decide to split up the work as such:
- Alice will write the Python program.
- Bob will add documentation to the README.

Let's start with Alice.
Here's the Python program she comes up with:

```python
print('Hello, world!')
```

That'll do the job just fine.
She adds it to the file `hello.py`:

```sh
echo "print('Hello, world!')" > hello.py
```

Happy with her changes, Alice dutifully adds a description to her commit:

```sh
jj describe --author "Alice <alice@local>" -m "Add Python script for greeting the world

Printing the text \"Hello, world!\" is a classic exercise in introductory
programming courses. It's easy to complete in basically any language and
makes students feel accomplished and curious for more at the same time."
```

The `--author` flag is just for extra realism, it sets Alice as the author of the commit.
Having completed her work, Alice creates a new commit with `jj new`.
Here's how the repository should look at this point:

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">vu</span><span class="bold highlighted dimgray ">qoxwyn</span><span class="bold "> </span><span class="bold yellow ">remo@buenzli.dev</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-11 22:46:00</span><span class="bold "> </span><span class="bold highlighted blue ">a</span><span class="bold highlighted dimgray ">afbcd23</span><span class="bold "></span>
│  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
○  <span class="bold "></span><span class="bold purple ">vr</span><span class="highlighted dimgray ">nvnxqt</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-07-11 22:45:52</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">e</span><span class="highlighted dimgray ">90b597e</span>
│  Add Python script for greeting the world
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">w</span><span class="highlighted dimgray ">rsozwlk</span> <span class="yellow ">remo@buenzli.dev</span> <span class="cyan ">2025-07-11 22:21:42</span> <span class="purple ">main</span> <span class="bold "></span><span class="bold blue ">c</span><span class="highlighted dimgray ">d5f3fff</span>
│  Add project description to readme
~
</pre>

Next, we simulate Bob's work.
He's working on a different computer than Alice, with a different copy of the repository.
Since Bob is working at the same time as her, he doens't have the commit made by Alice yet.
We can simulate that by creating a third repository, which has the same repository as our primary one:

```
jj git clone --colocate ~/jj-tutorial-remote ~/jj-tutorial-bob
```

Let's go into that directory and make sure the repo looks the same way as when Alice started her work:

```sh
cd ~/jj-tutorial-bob
jj log
```

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">o</span><span class="bold highlighted dimgray ">tpyrqss</span><span class="bold "> </span><span class="bold yellow ">remo@buenzli.dev</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-11 23:00:32</span><span class="bold "> </span><span class="bold highlighted blue ">c0</span><span class="bold highlighted dimgray ">1349fc</span><span class="bold "></span>
│  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">w</span><span class="highlighted dimgray ">rsozwlk</span> <span class="yellow ">remo@buenzli.dev</span> <span class="cyan ">2025-07-11 22:21:42</span> <span class="purple ">main</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">cd</span><span class="highlighted dimgray ">5f3fff</span>
│  Add project description to readme
~
</pre>

That looks great.
So now Bob is going to do his part the same way Alice did:

```sh
echo "
The file hello.py contains a script that greets the world.
It can be executed with the command 'python hello.py'.
Programming is fun!" >> README.md
jj describe --author "Bob <bob@local>" -m "Document hello.py in README.md"
jj new
```

Let's say that Bob was a little faster than Alice, because he was only doing the documentation.
Alice was doing actual software engineering, which took a little more time.
Therefore, Bob gets to update the main branch first:

```sh
jj bookmark move main --to @-
jj git push
```

A little later, Alice is also finished and now she attempts to update the `main` bookmark:

```sh
cd ~/jj-tutorial
jj bookmark move main --to @-
jj git push
```

Whoopsie!
Alice is met with a scary error message in her terminal:

<!-- generated by aha script -->
<pre class="aha">
Changes to push to origin:
  Move forward bookmark main from cd5f3fff9c7b to e90b597ed78e
<span class="bold "></span><span class="bold red ">Error: </span><span class="bold ">Failed to push some bookmarks</span>
<span class="bold "></span><span class="bold cyan ">Hint: </span>The following references unexpectedly moved on the remote:
  <span class="green ">refs/heads/main</span> (reason: stale info)
<span class="bold "></span><span class="bold cyan ">Hint: </span>Try fetching from the remote, then make the bookmark point to where you want it to be, and push again.
</pre>

Alice is about to panic, so she opens social media and scrolls a little until she finds a cat video.
Now that her nerves are calmed (the cat was snuggling with a bunch of baby ducks), she turns her attention back to the terminal and actually reads the error message.
She realizes that it actually contains all the information about what went wrong and how to fix it.
Following the hint, she first fetches from the remote:

```sh
jj git fetch
```

`fetch` is a new command, it's basically the opposite of `push`.
While `push` sends bookmarks and commits from the local repository to the remote, `fetch` downloads bookmarks and commits that someone else (like Bob!) may have pushed from another computer.

Here's the resulting `jj log`:

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">vu</span><span class="bold highlighted dimgray ">qoxwyn</span><span class="bold "> </span><span class="bold yellow ">remo@buenzli.dev</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-11 22:46:00</span><span class="bold "> </span><span class="bold highlighted blue ">a</span><span class="bold highlighted dimgray ">afbcd23</span><span class="bold "></span>
│  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
○  <span class="bold "></span><span class="bold purple ">vr</span><span class="highlighted dimgray ">nvnxqt</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-07-11 22:45:52</span> <span class="purple ">main?? main@git</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">e</span><span class="highlighted dimgray ">90b597e</span>
│  Add Python script for greeting the world
│ <span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">o</span><span class="highlighted dimgray ">tpyrqss</span> <span class="yellow ">bob@local</span> <span class="cyan ">2025-07-11 23:04:55</span> <span class="purple ">main?? main@origin</span> <span class="bold "></span><span class="bold blue ">f</span><span class="highlighted dimgray ">7a4622e</span>
├─╯  Document hello.py in README.md
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> <span class="bold "></span><span class="bold purple ">w</span><span class="highlighted dimgray ">rsozwlk</span> <span class="yellow ">remo@buenzli.dev</span> <span class="cyan ">2025-07-11 22:21:42</span> <span class="bold "></span><span class="bold blue ">c</span><span class="highlighted dimgray ">d5f3fff</span>
│  Add project description to readme
~
</pre>

Oh!
That's something we haven't seen before.
Our version history is split into two **branches**.
This is not unusal and lies at the core of how Jujutsu enables people to work independently from one another.

If Jujutsu allowed Alice to push the `main` bookmark where she wanted to, Bob's work would effectively get deleted.
Remember: The remote only considers commits worth keeping around if they are **reachable** from a bookmark.
But if the `main` bookmark points to Alice's commit, Bob's commit is **not reachable** anymore, because it is not an ancestor of Alice's commit.

That's all interesting and the tree-shaped graph of our commits looks very pretty, but the teacher wants a version that includes both the program and the documentation.
What should Alice and Bob do now?
Find out in the following chapters!
