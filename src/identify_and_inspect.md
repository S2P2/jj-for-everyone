# Identifying and inspecting changes

TODO learn about jj show before completing the second commit. keep identifying commits as separate section.

Now that we have a decent number of commits, we may want to refresh our mind about what changes were made in older commits.
This can be done with the command `jj show`:

<!-- generated by aha script -->
<pre class="aha">
Commit ID: <span class="blue ">8e0533cf0bd2cf41202cf319771d54c6edc62323</span>
Change ID: <span class="purple ">ztxovltlukzlzsllrskzwmtolknrzwzm</span>
Author   : <span class="yellow ">Remo Senekowitsch</span> &lt;<span class="yellow ">remo@buenzli.dev</span>&gt; (<span class="cyan ">2025-07-10 15:16:27</span>)
Committer: <span class="yellow ">Remo Senekowitsch</span> &lt;<span class="yellow ">remo@buenzli.dev</span>&gt; (<span class="cyan ">2025-07-10 15:16:27</span>)

<span class="green ">    (no description set)</span>
</pre>

By default, `jj show` assumes you want to see the content of the working copy.
This is useful for verifying the content and description of the working copy commit _before_ creating a new one.
Since we just did that, there's not much to see here.
To check the content of another commit, we need to pass some identification of that commit as an argument to `jj show`.
Let's use the change ID of the most recent commit we completed:

```sh
jj show ptttyorz # <- substitute your own change ID here
```

<!-- generated by aha script -->
<pre class="aha">
Commit ID: <span class="blue ">05440f7079c5ea5678321a72062abb5d0a5cda73</span>
Change ID: <span class="purple ">ptttyorzqupxmvzpzzmttovukqmrnrty</span>
Author   : <span class="yellow ">Remo Senekowitsch</span> &lt;<span class="yellow ">remo@buenzli.dev</span>&gt; (<span class="cyan ">2025-07-10 15:15:29</span>)
Committer: <span class="yellow ">Remo Senekowitsch</span> &lt;<span class="yellow ">remo@buenzli.dev</span>&gt; (<span class="cyan ">2025-07-10 15:16:03</span>)

    Add project description to readme

<span class="yellow ">Modified regular file README.md:</span>
<span class="red ">   1</span> <span class="green ">   1</span>: # jj-tutorial
     <span class="green ">   2</span>: <span class="underline "></span><span class="underline green "></span><span class="green "></span>
     <span class="green ">   3</span>: <span class="underline "></span><span class="underline green ">This is a toy repository for learning version control with Jujutsu.</span><span class="green "></span>
</pre>

That's better.
Here we can see a lot of information about a single commit, whereas `jj log` shows us what commits there are and their relationships.
Let's summarize what we see here:
- The first two lines are the commit ID and change ID.
  We've seen them already, but these ones are longer!
  That's because the output of `jj log` only shows you a **prefix** of the full ID.
  The prefix is usually enough to uniquely identify a commit, but sometimes you want the whole thing.
- The following two lines are the author, committer and their timestamps.
  Author and committer are usually the same, there's no need to worry about the difference.
- What follows is the commit description.
- Lastly, we see a list of files that have changed in this commit as well as the precise changes of their contents.
  The color green means "added", so we know this commit _added_ the third line in the file `README.md`.
  The first line is white, indicating that it was not changed in this commit.
  It's not visible here, but removed lines are highlighted in red.

There are several ways to identify a commit.
We just used a prefix of a change ID.
It's actually possible to use an even shorter prefix!
You may have noticed that the output of `jj log` highlights the first few characters of the change ID in purple, while the remaining ones are white.
The purple characters represent the **shortest unambiguous prefix**.

Let's say we also want to inspect the content of the first commit we completed.
The output of `jj log` shows in my case that the single character `r` is sufficient to identify the commit.
Therefore, I can simply run `jj show r`:

<!-- generated by aha script -->
<pre class="aha">
Commit ID: <span class="blue ">889387000bb79f4ec2989ca1f5a55693f6d6fa42</span>
Change ID: <span class="purple ">rnyzwzlpvvovnlynxupuzmppkkxxqptr</span>
Author   : <span class="yellow ">Remo Senekowitsch</span> &lt;<span class="yellow ">remo@buenzli.dev</span>&gt; (<span class="cyan ">2025-07-10 11:42:28</span>)
Committer: <span class="yellow ">Remo Senekowitsch</span> &lt;<span class="yellow ">remo@buenzli.dev</span>&gt; (<span class="cyan ">2025-07-10 14:21:14</span>)

    Add readme with project title

    It's common practice for software projects to include a file called
    README.md in the root directory of their source code repository. As the
    file extension indicates, the content is usually written in markdown,
    where the title of the document is written on the first line with a
    prefixed `#` symbol.

<span class="yellow ">Added regular file README.md:</span>
     <span class="green ">   1</span>: <span class="underline "></span><span class="underline green "># jj-tutorial</span><span class="green "></span>
</pre>

Notice that `jj show` displays the full commit message, not just the subject line like `jj log`.

Let's look at a couple more ways to identify commits.
Assume we also want to inspect the content of the root commit.
Here are some equivalent ways to do that: 

- `jj show 'root()'` - uses the special `root()` marker
- `jj show 00000000` - uses the commit hash prefix
- `jj show @---` - uses ✨ magic ✨

That last one is interesting.
It uses th `@` sign to identify the working copy, followed by the `-` minus sign three times.
The minus sign roughly means "it's parent".
So the expression `@---` could be translated to: "the working copy commit's parent's parent's parent" (or more concisely, it's great-grandparent).
In this case, that's the root commit.
This is an example of Jujutsu's [**revset language**](https://jj-vcs.github.io/jj/latest/revsets/), which allows you to identify commits based on properties and relationships, instead of just their ID.
It's incredibly useful, but there's no need to learn the entire language in one go.
We'll introduce more useful features of it in byte-sized chunks.
I only remember some of the most useful features myself.
For when I need something more elaborate, it's more efficient to just consult the documentation in that moment, rather than trying to memorize everything upfront.
I'd say the revset expression I use most often by far is `@-`.
Referring to the immediate parent of the working copy comes up a lot.

